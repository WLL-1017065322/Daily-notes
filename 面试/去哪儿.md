

# 课程介绍：

![1557075395609](assets/1557075395609.png)





![1557075408071](assets/1557075408071.png)



![1557075420655](assets/1557075420655.png)





![1557075432360](assets/1557075432360.png)



![1557075445753](assets/1557075445753.png)





![1557075461216](assets/1557075461216.png)





# Vue起步：

1，看官方文档

2，hello world



## vue小demo

![1557075668285](assets/1557075668285.png)









```js
    <script src="https://cdn.jsdelivr.net/npm/vue"></script>
</head>

<body>
    <div id="app">
        <input type="text" v-model="txt">
        <button class="btn" v-on:click="submit">提交</button>

        <ul>
            <li v-for="(item,index) in list" :key="index">{{item}}</li>
        </ul>
    </div>

</body>

<script>
    var vm = new Vue({
        el: '#app',
        data: {
            txt: '',
            list: [],
        },
        methods: {
            submit: function () {
                // console.log(this.txt)
                if(this.txt !== ""){
                this.list.push(this.txt)
                this.txt = ''
                }
            }
        }
    })
</script>
```





## mvp

![1557076964488](assets/1557076964488.png)



## jquery

 m 模型层 v 视图p 控制器





![1557077133211](assets/1557077133211.png)



## mvvm

m：data v：div上面  vm：

![1557077258258](assets/1557077258258.png)





前端组件化：

组件化思想修改小demo





## 全局组件/局部组件：

```

<body>
    <div id="app">
        <input type="text" v-model="txt">
        <button class="btn" v-on:click="submit">提交</button>

        <ul>
            <!-- <li v-for="(item,index) in list" :key="index">{{item}}</li> -->
            <list-to v-bind:content="item" v-for="(item,index) in list" :key="index"></list-to>
        </ul>
    </div>

</body>



<script>
    //全局组件===================================
    // Vue.component("listTo", {
    //     props: ['content'],  //组件间传值
    //     template: "<li>{{content}}</li>"
    // })
    //局部组件==================================
    var listTo = {
        props: ['content'],
        template: "<li>{{content}}</li>"

    }

    var vm = new Vue({
        el: '#app',
        data: {
            txt: '',
            list: [],
        },

        components: {
            listTo: listTo//=== 挂载
        },

        methods: {
            submit: function () {
                // console.log(this.txt)
                if (this.txt !== "") {
                    this.list.push(this.txt)
                    this.txt = ''
                }
            }
        }
    })
</script>

```







## 父子传值：

```js
<body>
    <div id="app">
        <input type="text" v-model="txt">
        <button class="btn" v-on:click="submit">提交</button>

        <ul>
            <!-- <li v-for="(item,index) in list" :key="index">{{item}}</li> -->
            <list-to v-bind:content="item" v-for="(item,index) in list" :key="index" @delete="listToClick"></list-to>//================
        </ul>
    </div>

</body>

<script>
    //全局组件
    // Vue.component("listTo", {
    //     props: ['content'],
    //     template: "<li>{{content}}</li>"
    // })
    var listTo = {
        props: ['content'],
        template: "<li v-on:click='listToClick'>{{content}}</li>",//===
       methods: {
        listToClick:function(){
            this.$emit("delete",this.index);//========
        }
       },

    }

    var vm = new Vue({
        el: '#app',
        data: {
            txt: '',
            list: [],
        },

        components: {
            listTo: listTo
        },

        methods: {
            submit: function () {
                // console.log(this.txt)
                if (this.txt !== "") {
                    this.list.push(this.txt)
                    this.txt = ''
                }
            },
            listToClick:function(index){//========
               this.list.splice(index,1)
            }
        }
    })
</script>
```



# 基础精讲

vm.$data

vm.$el

vm.$destory()



## 声明周期钩子：

![f847b38a-63fe-11e6-9c29-38e58d46f036.png](assets/3346068135-580822cd52898_articlex.png)

beforeCreate:

**beforeCreate（新对象诞生）**

Vue对象用新方法实例化。它创建一个Vue类的对象来处理DOM元素。对象的这个生命阶段可以通过beforeCreated 挂钩来访问   。我们可以在这个钩子中插入我们的代码，在对象初始化之前执行。



created

**创建（具有默认特性的对象）**

在这个生命阶段，对象及其事件完全初始化。 created 是访问这个阶段并编写代码的钩子。



beforeMount

**beforeMounted（对象在DOM中适合形状）**

这个钩子被调用  beforeMounted。在这个阶段，它检查是否有任何模板可用于要在DOM中呈现的对象。如果没有找到模板，那么它将所定义元素的外部HTML视为模板。



mounted

**已安装（DOM已准备就绪并放置在页面内）**

一旦模板准备就绪。它将数据放入模板并创建可呈现元素。用这个新的数据填充元素替换DOM元素。这一切都发生在mounted钩子上。



beforeUpdate

**beforeUpdate（更改已完成，但尚未准备好更新DOM）**

在外部事件/用户输入beforeUpdate发生更改时，此钩子即  在反映原始DOM元素的更改之前被触发。

为了解决这个问题  beforeUpdated，我添加了下面的代码。它通过更新DOM来更改运行时中的hello_message。



updated

**更新（在DOM中呈现的更改）**

然后，通过实际更新DOM对象并触发updated，屏幕上的变化得到呈现  。





beforeDestory

**beforeDestroy（对象准备死掉）**

就在Vue对象被破坏并从内存中释放之前，  deforeDestroy 钩子被触发，并允许我们在其中处理我们的自定义代码。

为了激发这个钩子，我添加了下面的代码来销毁Vue对象。



destroyed

**销毁（对象停止并从内存中删除）**

该  destroyed 钩子被成功运行销毁对象上调用。



![clipboard.png](assets/3504099265-580628fd03258_articlex.png)

 

```js
<!DOCTYPE html>
<html>
<head>
    <title></title>
    <script type="text/javascript" src="https://cdn.jsdelivr.net/vue/2.1.3/vue.js"></script>
</head>
<body>

<div id="app">
     <p>{{ message }}</p>
</div>

<script type="text/javascript">
    
  var app = new Vue({
      el: '#app',
      data: {
          message : "xuxiao is boy" 
      },
       beforeCreate: function () {
                console.group('beforeCreate 创建前状态===============》');
               console.log("%c%s", "color:red" , "el     : " + this.$el); //undefined
               console.log("%c%s", "color:red","data   : " + this.$data); //undefined 
               console.log("%c%s", "color:red","message: " + this.message)  
        },
        created: function () {
            console.group('created 创建完毕状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //undefined
               console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化 
               console.log("%c%s", "color:red","message: " + this.message); //已被初始化
        },
        beforeMount: function () {
            console.group('beforeMount 挂载前状态===============》');
            console.log("%c%s", "color:red","el     : " + (this.$el)); //已被初始化
            console.log(this.$el);
               console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化  
               console.log("%c%s", "color:red","message: " + this.message); //已被初始化  
        },
        mounted: function () {
            console.group('mounted 挂载结束状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el); //已被初始化
            console.log(this.$el);    
               console.log("%c%s", "color:red","data   : " + this.$data); //已被初始化
               console.log("%c%s", "color:red","message: " + this.message); //已被初始化 
        },
        beforeUpdate: function () {
            console.group('beforeUpdate 更新前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);   
               console.log("%c%s", "color:red","data   : " + this.$data); 
               console.log("%c%s", "color:red","message: " + this.message); 
        },
        updated: function () {
            console.group('updated 更新完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el); 
               console.log("%c%s", "color:red","data   : " + this.$data); 
               console.log("%c%s", "color:red","message: " + this.message); 
        },
        beforeDestroy: function () {
            console.group('beforeDestroy 销毁前状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);    
               console.log("%c%s", "color:red","data   : " + this.$data); 
               console.log("%c%s", "color:red","message: " + this.message); 
        },
        destroyed: function () {
            console.group('destroyed 销毁完成状态===============》');
            console.log("%c%s", "color:red","el     : " + this.$el);
            console.log(this.$el);  
               console.log("%c%s", "color:red","data   : " + this.$data); 
               console.log("%c%s", "color:red","message: " + this.message)
        }
    })
</script>
</body>
</html>
```

## vue模板语法：

插值表达式 {{msg}}

v-text

v-html



## 计算属性，方法和侦听器

### 计算属性：computed:{

}

![1557126686977](assets/1557126686977.png)

计算缓存



### 计算方法：

没有缓存

![1557126900506](assets/1557126900506.png)

### 侦听器：watch：{

}

会有缓存



![1557126968824](assets/1557126968824.png)



## 计算属性的setter个getter



![1557127073596](assets/1557127073596.png)







![1557127122161](assets/1557127122161.png)



## vue的样式绑定

isActivated

：class=“{activated：isActivated}”

data:{

isActivated:true/false

}



class:

![1557127401357](assets/1557127401357.png)

![1557127435786](assets/1557127435786.png)





![1557127453622](assets/1557127453622.png)





style:对象/数组



![1557127576158](assets/1557127576158.png) 





![1557127632353](assets/1557127632353.png)





![1557127721718](assets/1557127721718.png)





## vue中条件渲染

v-if：

![1557127835330](assets/1557127835330.png)

v-else：

v-else-if：

![1557128026490](assets/1557128026490.png)



v-show：存在

![1557127885460](assets/1557127885460.png)



key值的使用：

防止复用



![1557128094861](assets/1557128094861.png)



## 列表渲染：

数组循环

![1557128167802](assets/1557128167802.png)



key值：不推荐用index

性能最优

![1557128274934](assets/1557128274934.png)



修改数组不能通过修改下标的方式：



1只能通过vue提供的  push pop shift unshift  splice sort reverse

 

![1557128475133](assets/1557128475133.png)



2改变数组的引用地址：



template 占位符，不会渲染到页面

![1557128599469](assets/1557128599469.png)





对象的循环

![1557128692099](assets/1557128692099.png)





![1557128715407](assets/1557128715407.png)

通过修改引用添加数据：

![1557128763104](assets/1557128763104.png)





## vue中的set方法

对象：

**![1557128834784](assets/1557128834784.png)**



实例方法：

![1557128886555](assets/1557128886555.png)





数组：

![1557128992393](assets/1557128992393.png)



总结：

改变数组数据，页面跟着变：1，改变引用，2使用变异方法，3set

改变对象数据，页面跟着变：1，改变引用，2set







# 深入了解组件

## 组件使用细节

1is解决bug

![1557129202881](assets/1557129202881.png)

解决bug



![1557129233934](assets/1557129233934.png)





![1557129598710](assets/1557129598710.png)





![1557129604489](assets/1557129604489.png)





2子组件的data是一个函数 返回对象

防止各组件数据冲突

![1557129697147](assets/1557129697147.png)





3 ref获取dom节点

![1557129812515](assets/1557129812515.png)





![1557129911925](assets/1557129911925.png)









触发change事件  父组件监听change事件，执行change方法

  ![1557130149226](assets/1557130149226.png)







![1557130136075](assets/1557130136075.png)





div标签上时 获取的是标签的dom元素

组件上写ref  通过t$refs     获取的内容实际上是 counter子组件的一个引用



## 父子组件的数据传递：

1 **父组件通过属性传值**

子组件使用父组件的数据：父组件向字组件传递参数

子组件不能反过来改变父组件的参数

![1557130469430](assets/1557130469430.png)



要改变，自己创建一个数据来保存

 ![1557130691199](assets/1557130691199.png)





2**子组件通过事件触发的形式传值**



![1557133798115](assets/1557133798115.png)



![1557133786834](assets/1557133786834.png)





![1557133816820](assets/1557133816820.png)





## 组件参数校验与非props特性



组件参数校验：

![1557134093606](assets/1557134093606.png)



![1557134181817](assets/1557134181817.png)



自定义校验器：

![1557134233369](assets/1557134233369.png)





非props特性：

1，父传子不接，无法使用父组件的内容

2，属性会展示到子组件最外层的html标签的属性里

![1557134449319](assets/1557134449319.png)





## 组件绑定原生事件



1，在templateli的div加事件

![1557134643819](assets/1557134643819.png)



2在child加事件

父组件的事件无法触发：

![1557134700534](assets/1557134700534.png)





3 监听child的原生点击事件 .native



![1557134828888](assets/1557134828888.png)





## 非父子组件间的传值（Bus/总线/发布订阅模式/观察者模式）

![1557134877617](assets/1557134877617.png)   

​    

​     